package com.company.design.etc;

/*
    이해도 높이기
    - 불변 객체(Immutable Object) 및 final을 사용해야 하는 이유

    변경가능성이 없는 객체라면 final로 선언하여 불변성을 확보하도록 하자.
    내 코드를 읽거나 수정하는 다른 누군가는 final로 선언된 객체를 안전하게 사용할 수 있을 것이다.
    또한 자연스럽게 우리는 부수효과가 없는 순수 함수로 개발을 하게 될 것이다.

    불변 객체(Immutable Object)란 객체 생성 이후 내부의 상태가 변하지 않는 객체이다.
    불변 객체는 read-only 메소드만을 제공하며, 객체의 내부 상태를 제공하는 메소드를 제공하지 않거나
    제공하는 경우 방어적 복사(defensive-copy)를 통해 제공한다.

    출처: https://mangkyu.tistory.com/131 [MangKyu's Diary]
 */

public class Immutability {
    /*
        String

        Java의 String은 불변 클래스이기 때문에 위와 같이 name이라는 변수에 "New"를 할당하는 것은
        내부의 char를 변경하는 것이 아니라 새로운 값을 지니는 객체를 생성하는 것이다.
        또한 String 내부의 char형 배열을 얻어 수정하여도 반영이 되지 않는다.

        Java에서는 배열이나 객체 등의 참조(Reference)를 전달한다.
        그렇기 때문에 참조(Reference)를 통해 값을 수정하면 내부의 상태가 변하기 때문에 내부를 복사하여 전달하고 있는데,
        이를 방어적 복사(defensive-copy) 라고 한다.

     */
    public static void main(String[] args) {
        String name = "강수희";
        System.out.println(name.hashCode());

        name = "New"; // new String
        System.out.println(name.hashCode());

        // String의 toCharArray 복사 전달
        name.toCharArray();

    }

    /*
        불변 객체 및 final을 사용해야 하는 이유

        1. Thread safe 환경에서의 고려
            Thread Safe하지 않은 상황은 멀티 쓰레드 환경에서 공유 자원에 동시에 쓰기(Write)하기 때문이다.
            불변 자원이라면 항상 동일한 값을 반환하여 안정성 보장 및 동기화를 고려하지 않음으로의 성능상의 이점을 가져다준다.

        2. 실패 원자적인 메소드 (Failure Atomic Method)
            가변 객체를 통해 어떠한 작업을 하는 도중 예외가 발생하면 해당 객체가 불안정한 상태에 빠질 수 있다.
            불안정한 상태는 또 다른 에러를 발생시킬 수 있지만
            불변 객체라면 메소드 호출 전의 상태를 유지할 것이다.

            [Effective Java 3th Edition] https://madplay.github.io/post/strive-for-failure-atomicity
            - 가능한 실패 원자적인 메소드를 작성하라

        3. Cache, Map, Set 등의 요소로 활용하기에 더욱 적합하다.
            만약 캐시나 Map 또는 Set 등으로 사용되는 객체가 변경되었다면 이를 갱신하는 등의 작업을 추가로 해주어야 할 것이다.
            하지만 객체가 불변이라면 한 번 데이터가 저장된 이후에 다른 부가 작업들을 고려하지 않아도 될 것이고,
            이는 캐시나 다른 자료 구조를 사용하는데 용이하게 작용할 것이다.

        4. 부수 효과(Side Effect)를 피해 오류가능성을 최소화할 수 있다.
            부수 효과란 변수의 값이 변경되거나, 필드 값이 설정되는 등의 변화가 발생하는 효과를 의미한다.
            만약 객체의 수정자(Setter)가 구현되어 있고, 여러 메소드에서 객체의 값이 변경된다면 객체를 예측하기 어려워질 것이다.
            객체의 바뀐 상태를 파악하기 위해서는 메소드들을 살펴보아야 할 것이며 이러한 부분은 유지보수성을 상당히 떨어뜨린다.
            그래서 이러한 부수효과가 없는 "순수 함수"들을 만드는 것이 상당히 중요합니다.

            불변 객체는 기본적으로 값의 수정이 불가능하기 때문에 변경 가능성이 적으며, 객체의 생성과 사용이 상당히 제한된다.
            그렇기 때문에 메소드들은 자연스럽게 순수 함수들로 구성될 것이고, 다른 메소드가 호출되어도 객체의 상태가 유지되기 때문에
            안전하게 객체를 다시 사용할 수 있다.
            이러한 불변 객체는 오류를 줄여 유지보수성이 높은 코드를 작성하도록 도와줄 것이다.

        5. 다른 사람이 작성한 함수를 예측가능하며 안전하게 사용할 수 있다.
            불변성(Immutability)은 협업을 하는 과정에서도 도움을 주는데, 불변성이 보장된 함수라면 다른 사람이 개발한 함수를 위험없이 이용할 수 있다.
            마찬가지로 다른 사람도 내가 작성한 메소드를 호출하여도, 값이 변하지 않음을 보장받을 수 있다.
            그렇기에 우리는 다른 사람의 코드를 변경에 대한 불안없이 이용할 수 있다.

        6. 가비지 컬렉션의 성능을 높일 수 있다. (!)
            불변성(Immutability)을 활용하는 것은 많은 이점을 가져다주는데, 그 중에서 많은 사람들이 놓치는 것이 바로 GC의 성능을 높여준다는 것이다.
            불변의 객체는 한번 생성된 이후에 수정이 불가능한 객체로, Java에서는 final 키워드를 사용하여 불변의 객체를 생성할 수 있다.

            이렇게 객체를 생성하기 위해서는 객체를 가지는 또 다른 컨테이너 객체(ImmutableHolder)도 존재한다는 것인데,
            당연히 불변의 객체(Object value)가 먼저 생성되어야 컨테이너 객체가 이를 참조할 수 있을 것이다.

            즉, 컨테이너는 컨테이너가 참조하는 가장 젊은 객체들보다 더 젊다는 것(늦게 생성되었다는 것)이다. 이를 정리하면 다음과 같다.
                1) Object 타입의 value 객체 생성
                2) ImmutableHolder 타입의 컨테이너 객체 생성
                3) ImmutableHolder가 value 객체를 참조
            이러한 점은 GC가 수행될 때, 가비지 컬렉터가 컨테이너 객체 하위의 불변 객체들은 Skip할 수 있도록 도와준다.
            왜냐하면 해당 컨테이너 객체(ImmutableHolder)가 살아있다는 것은,
            하위의 불변 객체들(value) 역시 처음에 할당된 그 상태로 참조되고 있다는 것을 의미하기 때문이다.
            결국 불변의 객체를 활용하면 가비지 컬렉터가 스캔해야 되는 객체의 수가 줄어서
            스캔해야 하는 메모리 영역과 빈도수 역시 줄어들 것이고, GC가 수행되어도 지연 시간을 줄일 수 있을 것이다.

     */

}
